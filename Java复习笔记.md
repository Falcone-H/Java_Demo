## 封装、继承和多态

1、子类重写父类的方法，访问权限不能降低

2、子类重写父类的方法，返回值类型要相同

3、`实例方法可直接调用超类的实例方法和类方法`错误。实例方法不能调用超类的私有实例方法和私有类方法。

4、对象浅拷贝：不拷贝对象和数组，只拷贝基本类型

5、对象深拷贝：对象、对象内部的引用，均被赋值

6、最终类（final class）：把一个类的功能固定下来，不允许定义它的子类对其进行扩充

7、子类可以重定义从父类继承来的成员

8、`super(参数列表)`在子类构造方法中必须放在最前面

9、方法重载属于编译时多态，可以在编译阶段确定执行重载方法中的哪一个

10、方法覆盖，如果对象引用的是本类的实例，则在编译时也能确定具体调用哪个方法，属于编译时多态；如果对象引用的是子类的实例，则属于运行时多态，需要等到运行时动态确定是调用子类还是父类的方法，从引用的实例类开始寻找，逐级往上查找祖先类，直到找到为止，若始终没找到即报运行时错误。

11、最终类中包含的方法通常都是最终方法

12、最终方法不能被子类覆盖

13、非最终类也可以包含最终方法

14、子类实例化：

* 子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句`super()`
* 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过`super`语句指定要访问的父类中的构造函数
* 如果子类构造函数中用`this`来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数

15、子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。

## 接口

1、接口不能有构造方法

2、接口的方法都是抽象的

3、接口的数据成员都是常量

4、接口变量可引用实现类的实例

5、接口中的属性只能被`public`, `final`, `static`修饰

6、抽象类中的方法如果被`abstract`修饰，则没有方法体，否则需要方法体；但接口中的方法都没有方法体。

##　线程

１、并发执行的线程的运行结果具有不确定性

2、`interupt()`不能中断在运行中的线程，只能改变中断的状态，即只能通知该线程应该停止了

3、Java中定义了三种优先级，分别是`最低优先级(1)`、`正常优先级(5)`、`最高优先级(10)`

4、Java中优先级范围是【1，10】

5、线程互斥：某一资源同时只允许一个访问者对其进行访问

6、进程动态特征表现为就绪、运行和阻塞三种状态

7、线程调度采用剥夺方式。就绪线程按优先级排队，遵循先到先服务原则

8、把互斥线程的共享变量代表的资源称为临界资源，而线程中操纵共享变量的程序段则称为临界区。

9、操作系统对共享变量的若干线程进入临界区有以下三个调度原则：

​		一次至多一个线程能够在它的临界区内

​		不能让一个线程无限地留在它的临界区内

​		不能强迫一个线程无限地等待进入它的临界区。特别地，进入临界区的任一线程不能妨碍正等待进入的其他线程的进展

10、并发和并行的区别

* 并发：指两个或多个事件在同一时间间隔发生
* 并行：指两个或多个事件在同一时刻发生

11、线程和进程的区别

* 一个程序至少有一个进程
* 一个进程至少有一个线程

12、守护线程（即`Daemon thread`），是个服务线程，准确来说就是服务其他的线程。

13、线程通常有五种状态：创建、就绪、运行、阻塞和死亡

14、`sleep()`和`wait()`的区别

* `sleep()`是`Thread`类的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠结束后，线程进入就绪状态，和其他线程一起竞争CPU的执行时间。因为`sleep()`是`static`静态方法，不能改变对象的机锁，当一个`synchronized`块中调用`sleep()`方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象
* `wait()`是`Object`类的方法，当一个线程执行到`wait()`方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过`notify()`和`notifyAll()`方法来唤醒等待的线程

15、`notify()`和`notifyAll()`的区别

* 如果线程调用了对象的`wait()`方法，那么线程便会处于该对象的等待池中，等待池中的线程不会竞争该对象的锁
* 当线程调用了对象的`notifyAll()`方法（唤醒所有`wait`线程）或`notify()`方法（只随机唤醒一个`wait`线程），被唤醒的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了`notify`后只有一个线程会由等待池进入锁池，而`notifyAll`会将该对象等待池中的所有线程移动到锁池中，等待锁竞争

16、`synchronized`实现同步的基础

* 普通同步方法，锁是当前实例对象
* 静态同步方法，锁是当前类的class对象
* 同步方法块，锁是括号里面的对象

## 反射

1、反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力

2、Java反射机制主要提供了以下功能

* 在运行时判断任意一个对象所属的类
* 在运行时构造任意一个类的对象
* 在运行时调用任意一个对象的方法

3、动态代理：

​	当想要给实现了某个接口的类中的方法，加一些额外的处理，比如说加日志，加事务等。可以给这个类创建一个代理，就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。

​	这个代理类并不是定义好的，而是动态生成的。具有解耦意义，灵活，扩展性强。

## 数据库

1、在关系模型中，关系即为一张规范化的二维表，代表一个实体集，表的每一行表示一个实体，表的每个列表示实体的一个属性

2、`Connection`接口：表示数据库连接

3、`DriverManager`类：表示驱动管理器

4、`ResultSet`接口：表示`SQL`查询语句返回的结果集

５、`Statement`接口：负责执行`SQL`语句

6、如果想要执行存储过程，应该使用`CallableStatement`接口

## IO流

1、`RandomAccessFile`类提供对文件进行随机存取的方法，可以读写文件指定位置的数据

2、按功能来分：输入流、输出流

​	按类型来分：字节流、字符流

3、字节流和字符流的区别：字节流按8位传输，以字节位单位输入输出数据；字符流按16位传输，以字符位单位输入输出数据

##　网络编程

１、通过`URLConnection`类可获得`Intrenet`资源的大小、类型等信息

2、`InetAddress`类提供了将主机名解析为`IP`地址（或反之）的方法

3、`IP` 协议是一个无连接协议，提供“不承诺”的通信服务

4、`TCP`协议是一个面向连接的协议，能提供可靠的数据传输服务

5、`UDP`协议是一个无连接协议，不能完全确保数据传输的可靠性

6、`TCP`连接属于点对点连接，不支持组播功能

7、`UDP`数据报通信支持单播和组播

## 抽象

1、抽象方法可以在子类中被重写，但静态方法不能在子类中被重写。静态方法和静态属性与对象无关，只与类有关。

2、abstract不能与final并列修饰一个类

3、abstract类中可以声明private成员

4、abstract方法必须在abstract类中，即有抽象方法，一定是抽象类；但抽象类不一定有抽象方法

5、包含抽象方法的类必须被声明为抽象类，但抽象类中的方法不一定全是抽象方法

6、`抽象方法的body部分必须用一对大括号{}包住`错误。abstract修饰方法和类，不修饰属性。且抽象方法没有方法体，不可以写出大括号

7、构造方法不能声明为抽象方法

8、静态方法不能声明为抽象方法

9、非抽象类必须实现从父类继承来的所有抽象方法

10、抽象关键字`abstract`和`final`, `private`, `static`不可以共存

## 异常

1、`Exception`和`Error`类的父类是`Throwable`，提供`getMessage()`方法获取异常信息，`printStackTrace()`输出异常栈跟踪信息

## 图形化

1、Java实现图形用户界面的组件包有`java.awt`和`java.swing`两个，所有实际使用的组件都是`Component`类的子类

2、`GridLayout`可以创建网格布局，网格布局中各组件的大小不可以任意调整

3、要使用布局管理器，必须导入`java.awt.*`包

4、`BoxLayout`不属于`java.awt.*`包中的布局管理器

5、`java.awt`包主要包括下述三个概念：

* 组件——`Component`
* 容器——`Container`
* 布局管理器——`LayoutManager`

6、`Container`是一个类，实际上是`Component`的子类，因此容器本身也是一个组件，具有组件的所有性质，但是它的主要功能是用来放置其他组件和容器

7、有三种类型的容器：`Window`, `Panel`, `ScrollPane`, 常用的有`Panel`, `Frame`, `Applet`

8、布局管理器相关类主要包括：`FlowLayout`, `BorderLayout`, `GridLayout`, `CardLayout`

* `FlowLayout`是`Panel` 和`Applet`的默认布局管理器，组件容器中放置的规律是从上到下，从左到右。如果当前行放不下该组件，则防止在下一行的最左边
* `BorderLayout`是`Window`, `Frame`和`Dialog`的默认布局管理器。`BorderLayout`布局管理器把容器分成五个区域：`North`, `South`, `East`, `West`, `Center`，每个区域只能放置一个组件
* `GridLayout`使容器中的各个组件成网格状布局，平均占据容器的空间，即使容器的大小发生变化，每个组件还是平均占据容器的空间
* `CardLayout`能够帮助用户处理两个以上，甚至更多的成员共享同一显示空间，它把容器分成很多层，每层的显示空间占据整个容器的大小，但是每一层只允许放置一个组件，每层都可以利用`Panel`来实现复杂的用户界面

9、`AWT`事件处理，主要涉及以下三类对象：

* `Event`事件，用户对界面操作在Java语言上的描述，以类的形式出现
* `Event Source`事件源，事件发生的场所，通常就是各种组件
* `Event Handler`事件处理者，接受事件对象并对其进行处理的对象
* 添加方法：`addActionListener()`

10、`java.lang.EventObject`类是所有事件对象的基础父类，所有事件都是由它派生出来的

11、`java.awt.AWTEvent`派生出所有与`AWT`有关的事件类，这些`AWT`事件被分为低级事件和高级事件两大类：

* 低级事件是基于组件和容器的事件，如鼠标点击、进入等，都是低级事件
* 高级事件可以不和特定的动作相关联，而依赖于触发此事件的类

12、低级事件：

* `ComponentEvent`组件事件：组件尺寸的变化、移动
* `ContainerEvent`容器事件：组件的增加，移动
* `WindowEvent`窗口事件：关闭窗口，移动

13、高级事件：

* `ActionEvent`动作事件：比如按钮按下，`TextField`中按`Enter`键
* `TextEvent`文本事件：文本对象改变

14、事件适配器：Java语言为一些`Listener`接口提供了适配器（`Adapter`）类，`java.awt.event`包中定义的事件适配器有：

* `ComponentAdapter`组件适配器
* `ContainerAdapter`容器适配器
* `FocusAdapter`焦点适配器
* `KeyAdapter`键盘适配器

## 基础

### 变量

1、由static修饰的变量称为类变量或是静态变量

2、方法加载的时候创建局部变量

3、以下程序会输出`9`

```
static int x= 0;
    static {
        x += 5;
    }
    public static void main(String[] args) {
        System.out.println(x);
    }
    static {
        x += 4;
    }
```

代码会执行所有自由块之后，最后执行main函数

5、标识符：以字母开头的字母、数字、下划线和美元符号序列

6、关键字：Java语言定义的，具有特定含义的单词

7、符号常量：指用关键字final声明的保存在程序中不能改变的数据

8、隐式类型转换：Java数据类型从低类型转换为高类型

9、显示类型转换：Java数据类型从高类型转换为低类型

### 编译

10、编译后的Java应用程序可由`Java.exe`解释执行

11、Java源程序经编译后生成字节码文件

12、`javac.exe `Java的编译器，将`.java`文件编译成`.class`文件，即将源代码文件编译成字节码文件

13、`java.exe` Java的解释器，启动`JVM`。将`.class`文件解释成机器指令执行

14、用命令行解释执行Java应用程序格式

`java <class文件名>`一定不能包含`.class`扩展名

15、命令行编译Java应用程序必须包含扩展名`.java`

16、命令行执行Java程序步骤

* `javac file_name.java`编译

* `java file_name`执行

17、语义错误和语法错误

* 语法错误：在编译期被发现，比如少了一边括号
* 语义错误：运行结果错误，比如代码逻辑有问题

18、Java系统本身对程序的逻辑错误没有识别能力

### 运算

19、Java的浮点数没有特别指明，都是属于双精度（double）

20、Java字符以Unicode码表示

21、Java的字符串必须在一行内写完，不然需要用加号连接

22、所有的赋值运算符都具有右结合性，就是在表达式中，最右边的操作先执行

23、条件运算符，即三目运算符

24、表达式的结果类型为范围大、精度高的那种数据类型

25、字符是一种数值类型，可与整数、浮点数进行算数运算

26、把多个语句用括号`{}`包起来组成的一个语句称为复合语句

27、Java用于判断的条件表达式必须为布尔类型

28、`switch`后的表达式类型不能为浮点型

29、`do-while`语句条件表达式后必须有一个分号

30、只有单目运算符、条件运算符、赋值运算符是从右到左结合的，其他的都是从左到右结合

31、可以用以下方法获取变量的数据类型

```
public String getType(Object o) {
	return o.getClass().toString();
}
```

### 参数

1、数组属于引用数据类型

2、用另一数组给某数组赋值可能会改变该数组的存储分配

3、Java的二维数组可以分解为若干个一维数组

4、Java支持不规则（变长）二维数组

5、Java不支持类之外的全局变量和全局函数

6、`main`方法只能由Java虚拟机直接调用，其他方法不能调用它

### 类

1、一个类的成员变量可以和成员方法同名

2、声明了有参构造方法后，类的默认无参构造方法将不再可用，除非重写

3、设置为缺省访问权限（default）的类只可被同一个包中的类访问

4、一个文件中可以定义多个类，但是只能有一个public的类，而且Java文件名必须和这个public类相同

5、访问修饰符限制性最高的是`private`

6、`构造函数的返回值类型只能是void型`这句话是错误的，构造函数不能指定返回类型

### 静态

1、非静态方法既可以访问静态数据成员，又可以访问非静态成员，而静态方法只能访问静态数据成员

### 引用

1、对于`==`，基本类型是比较值是否相同；引用类型是比较引用是否相同

2、`equals`本质上就是`==`，只不过`String`和`Integer`等重写了`equals`方法，把它变成了值比较

## 数据类型

1、以下程序会输出`9.0`

```
public static void main(String[] args) {
        int x = 4;
        System.out.println((x > 4) ? 99.9 : 9);
    }
```

在三目运算符中，第二个表达式和第三个表达式如果都为基本数据类型，那么整个表达式的运算结果由容量高的决定。

2、以下程序会输出`5`

```
public static void main(String[] args) {
        Set<Short> set = new HashSet<>();
        for(Short i = 0; i < 5; i++) {
            set.add(i);
            set.remove(i - 1);
        }
        System.out.println(set.size());
    }
```

因为加入的`i`为short类型，要移除的`i-1`为int类型，所以移除失败

3、String类的`indexOf()`方法返回值类型为`int`

```
public int indexOf(int ch) {
	return indexOf(ch, 0);
}
```

4、`String[] str = new String[10];`执行该语句后，`str[9]`为`null`。因为String类型的默认值为null

5、在Java中，char是一个无符号16位类型，取值范围为0到65535

6、下面的程序会编译错误

```
public static void main(String[] args) {
    String str = null;
    System.out.println(str);
}
```

null应该为小写

7、声明数组的几种方式

* `int[] a = new int[5];`
* `int[] a = {1, 2, 3};`
* `int a[] = {1, 2, 3};`
* `int a[][] = {{1, 2}, {3, 4}};`
* `int[][] a = {{1, 2}, {3, 4}};`

8、`Character`流和`Byte`流的区别：前者是字符读写，后者是字节读写

9、`byte, short, char`三个平级-->`int`-->`float`-->`long`-->`double`

10、引用数据类型：除去基本数据类型的其他类型都是引用数据类型

### 字符串

1、两个对象的`hashCode()`相同，`equals()`也不一定为`true`

​	在散列表中，`hashCode()`相等，即两个键值对的哈希值相等，然而哈希值相等，不一定能得到键值对相等

2、操作字符串的类：`String`, `StringBuffer`, `StringBuilder`

* `String`声明的是不可变的对象，每次操作都会生成新的`String`对象，然后将指针指向新的`String`对象
* `StringBuffer`和`StringBuilder`可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用`String`
* `StringBuffer`是线程安全的，而`StringBuilder`是非线程安全的
* `StringBuilder`的性能高于`StringBuffer`
* 在单线程环境下推荐使用`StringBuilder`，多线程环境下推荐使用`StringBuffer`

3、`String str = "i"`与`String str = new String("i")`的区别

​	内存的分配不一样。第一种方式，Java虚拟机会将其分配到常量池中；而第二种方式，则会北分到堆内存中

4、`str.subString(int beginIndex, int endIndex)`会从`str`中取出下标从`beginIndex`到`endIndex - 1`的子串

## 垃圾回收

1、垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，即使程序员能明确地判断出有一块内存已经无用了，是应该回收的，程序员也不能强制垃圾收集器回收该内存块。程序员唯一能做的就是通过`System.gc()`方法来“建议”执行垃圾收集器，但其是否可以执行，什么时候执行却是不可知的。

## 其他

1、`Applet`：采用Java创建的基于HTML的小应用程序

2、`Serialist`：服务端的Java应用程序（可以生成动态的网页）

3、`Jacobeans`：一种在Java（包括JSP）中使用可重复使用的Java组件的技术规范

4、`包（package）`：防止同名的类名发生冲突，所以封装在一个包下面

5、`JDK`：Java Development Kit 的简称，Java开发工具包，提供了Java的开发环境和运行环境

6、`JRE`：Java Runtime Environment 的简称，Java运行环境，为Java的运行提供了所需环境

7、Java序列化

* 序列化是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来

8、以下情况需要序列化：

* 当你想把内存中的对象状态保存到一个文件中或者数据库中的时候
* 当你想用套接字再网络上传送对象的时候
* 当你想通过`RMI`传输对象的时候

9、Java的字符类型采用的是Unicode编码方案，每个Unicode码占用32个比特位

10、结构化程序涉及所规定的三种基本控制结构是：顺序、选择、循环

11、Java编程所必须的默认引用包为`java.lang`包

12、Java内存（寄存器、本地方法区、方法区、栈、堆）

* 栈：存储的是局部变量（函数中定义的变量，函数上的参数，语句中的变量），只要数据运算完成所在的区域结束，该数据就会被释放
* 堆：用于存储数组和对象，也就是实体，每一个实体都有内存首地址值。还有垃圾回收机制。

